var redis = require('redis'),
    connections = {},
    util = require('util'),
    connectionWaitings = {};

var parseConnectionString = function(connectionString) {
    var ret = {};
    var items = connectionString.split(';');
    for (var i in items) {
        var pair = items[i].split('=');
        if (pair.length == 2) {
            ret[pair[0]] = pair[1];
        }
    }
    return ret;
};

var redisfactory = function(connectionString, cb, usenewConnection) {
    if (!usenewConnection) {
        // Get connection from pool first.
        if (connections[connectionString]) {
            cb(false, connections[connectionString]);
        } else if (connectionWaitings[connectionString]) {
            // If waiting list is already there. add callback into it
            connectionWaitings[connectionString].push(cb);
        } else {
            // Prepare waiting list.
            connectionWaitings[connectionString] = [cb];

            // Connect server and cache connection.
            var svrSetting = parseConnectionString(connectionString);
            if (redis.createClient) {
                var client = redis.createClient(svrSetting.port, svrSetting.host);

                client.on('ready', function() {
                    //console.log('Redis Ready : ' + connectionString);

                    connections[connectionString] = client;

                    // Get the waiting list.
                    var waitingList = connectionWaitings[connectionString];

                    // Clear waiting list first. avoid crashing in callback.
                    connectionWaitings[connectionString] = undefined;

                    // Callback when ready.
                    for (var key in waitingList) {
                        waitingList[key](0, client);
                    }
                });

                client.on('error', function() {
                    //console.error.apply(console, arguments);
                    if (connections[connectionString] === client) {
                        connections[connectionString] = undefined;
                    }

                    // Get the waiting list.
                    var waitingList = connectionWaitings[connectionString];

                    // Clear waiting list first. avoid crashing in callback.
                    connectionWaitings[connectionString] = undefined;

                    // Callback when error.
                    for (var key in waitingList) {
                        waitingList[key](arguments[0]);
                    }
                });

                client.on('end', function() {
                    //console.log.apply(console, arguments);
                    if (connections[connectionString] === client) {
                        connections[connectionString] = undefined;
                    }
                });
            }
        }
    } else {
        var svrSetting = parseConnectionString(connectionString);
        if (redis.createClient) {
            var client = redis.createClient(svrSetting.port, svrSetting.host);
            cb(0, client);

            client.on('error', function(err) {
                console.error('redis connect err:' + util.inspect(err) + ', start reconnect...');
            });

            client.on('end', function() {
                if (client.end) {
                    client.end();
                }
                console.error('redis connect end, start reconnect...');
                reconnect(svrSetting.port, svrSetting.host, cb);
            });
        }
    }
};

var reconnect = function(port, host, cb) {
    var newclient = redis.createClient(port, host);
    newclient.on('error', function(err) {
        console.error('redis connect err:' + util.inspect(err) + ', start reconnect...');
    });

    newclient.on('end', function() {
        console.error('redis connect end, start reconnect...');
        if (newclient.end) {
            newclient.end();
        }
        setTimeout(function() {
            reconnect(port, host, cb);
        }, 10000);
    });
    cb(0, newclient);
}


module.exports = function(connectionStrings, cb, useCachedConnection) {
    var useCachedConn = useCachedConnection || true; //default value true
    var connectionStr = connectionStrings;
    if (toString.call(connectionStrings) === '[object Array]') {
        var index = (Math.floor(Math.random() * connectionStrings.length));
        connectionStr = connectionStrings[index];
    }

    redisfactory(connectionStr, cb, useCachedConnection);
};